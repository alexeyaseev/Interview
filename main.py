import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
import random
import numpy as np

BOARD_SIZE = 10

class MyPolygon:
    def __init__(self, points):
        self._points = points
        self._data = np.full((BOARD_SIZE, BOARD_SIZE), '')

    def draw(self):
        p = Polygon(self._points, fill=False, color='blue', lw=3, closed=True)
        fig, ax = plt.subplots()
        ax.add_patch(p)
        import numpy as np
        ticks = np.arange(1, BOARD_SIZE + 1, 1)
        ax.set_xticks(ticks)
        ax.set_yticks(ticks)
        plt.xlim(1, BOARD_SIZE)
        plt.ylim(1, BOARD_SIZE)
        plt.grid()
        plt.show()

    def __str__(self):
        res = '\n'
        for y in range(BOARD_SIZE):
            row = ''.join(map(lambda value: value if value else ' ', p._data[y, ]))
            if row.strip():
                res += row + '\n'
        return res

    def square(self):
        num_of_brackets = 0
        area = 0
        start = 0
        for i in range(BOARD_SIZE):
            for j in range(BOARD_SIZE):
                if self._data[i, j]:
                    num_of_brackets += 1
                    if num_of_brackets % 2 != 0:
                        start = j
                    else:
                        end = j
                        area += end - start
        return area

    def convert(self):
        for point_start, point_stop in zip(self._points, self._points[1:] + [self._points[0]]):
            y, x = min(point_start[1], point_stop[1]), min(point_start[0], point_stop[0])
            y = BOARD_SIZE - y
            value = (point_stop[1] - point_start[1]) * (point_stop[0] - point_start[0])
            value = '/' if value == 1 else '\\'
            self._data[y, x] = value

    @staticmethod
    def generate():
        def generate_path(start, stop):
            height = stop[1] - start[1]
            width = stop[0] - start[0]
            moves = ['up'] * ((width + height) // 2)
            moves.extend(['down'] * (width - len(moves)))
            random.shuffle(moves)
            move_map = {'up': 1, 'down': -1}
            res = start
            yield start
            for move in moves[:-1]:
                res = (res[0] + 1, res[1] + move_map[move])
                yield res
            yield stop

        start_point = (1, random.randint(BOARD_SIZE * 0.4 // 1, BOARD_SIZE * 0.6 // 1))
        stop_point = (BOARD_SIZE, random.randint(BOARD_SIZE * 0.4 // 1, BOARD_SIZE * 0.6 // 1))
        if (start_point[1] - stop_point[1]) % 2 == 0:  # height + width should be divisible by 2
            stop_point = (stop_point[0], stop_point[1] + 1)
        # generage upper path
        upper_path_start_point = (2, start_point[1] + 1)
        upper_path_stop_point = (BOARD_SIZE - 1, stop_point[1] + 1)
        upper_path = [(1, BOARD_SIZE + 1)]
        while max(upper_path, key=lambda point: point[1])[1] > BOARD_SIZE:  # path should not exceed board size
            upper_path = list(generate_path(upper_path_start_point, upper_path_stop_point))
        # generate lower path
        lower_path_start_point = (2, start_point[1] - 1)
        lower_path_stop_point = (BOARD_SIZE - 1, stop_point[1] - 1)
        lower_path = upper_path
        counter = 1
        # path should not exceed board size AND intersections are not allowed
        while max(upper_path, key=lambda point: point[0])[0] < 1 \
                or set(lower_path) & set(upper_path):
            lower_path = list(generate_path(lower_path_start_point, lower_path_stop_point))
            counter += 1
            if counter >= 100:
                raise("Conditions are too strict for generating polygons")
        print(f"Polygon generated by '{counter}' attempts")
        full_path = [start_point] + upper_path + [stop_point] + lower_path[::-1]
        return MyPolygon(full_path)



#p = MyPolygon([(1, 1), (3, 3), (3, 1)])
p = MyPolygon.generate()
p.convert()
print(p)
p.draw()
square = p.square()
print(f"Polygon square equal to: {square}")
pass